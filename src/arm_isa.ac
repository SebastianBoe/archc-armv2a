/**
 * @file      arm_isa.ac
 * @author    Danilo Marcolin Caravana
 *            Rafael Auler 
 *
 *            The ArchC Team
 *            http://www.archc.org/
 *
 *            Computer Systems Laboratory (LSC)
 *            IC-UNICAMP
 *            http://www.lsc.ic.unicamp.br/
 *
 * @version   1.0
 * @date      Apr 2012
 * 
 * @brief     The ArchC ARMv5e functional model.
 * 
 * @attention Copyright (C) 2002-2012 --- The ArchC Team
 *
 */

//BOE: Comments prefixed with BOE were made during the port from ARMv5e to ARMv2a. 

AC_ISA(arm) {	
  ac_helper {
    #include "arm_isa_helper.H" 
  };

  // BOE: The data processing instructions are identical from armv2a to armv5e according to the Amber spec.
  /* Data processing instructions - ALU */
  ac_format Type_DPI1 = "%cond:4 %op:3 %func1:4 %s:1 %rn:4 %rd:4 %shiftamount:5 %shift:2 %subop1:1 %rm:4";
  ac_format Type_DPI2 = "%cond:4 %op:3 %func1:4 %s:1 %rn:4 %rd:4 %rs:4 %subop2:1 %shift:2 %subop1:1 %rm:4";
  ac_format Type_DPI3 = "%cond:4 %op:3 %func1:4 %s:1 %rn:4 %rd:4 %rotate:4 %imm8:8"; 

  /* Branch instructions */
  ac_format Type_BRANCH    = "%cond:4 %op:3 %h:1 %offset:24";
  
  ac_format Type_MULT = "%cond:4 %op:3 %func1:4 %s:1 %rd:4 %rn:4 %rs:4  %subop2:1 %func2:2 %subop1:1 %rm:4";
  ac_format Type_SWAP = "%cond:4 %op:3 %func1:4 %s:1 %rn:4 %rd:4 %sbz:4 %subop2:1 %func2:2 %subop1:1 %rm:4";
  // BOE: sbz are zeroed.

  /* Load/Store */
  ac_format Type_LSI = "%cond:4 %op:3 %p:1 %u:1 %b:1 %w:1 %l:1 %rn:4 %rd:4 %imm12:12";
  ac_format Type_LSR = "%cond:4 %op:3 %p:1 %u:1 %b:1 %w:1 %l:1 %rn:4 %rd:4 %shiftamount:5 %shift:2 %subop1:1 %rm:4";

  ac_format Type_MTRANS = "%cond:4 %op:3 %p:1 %u:1 %r:1 %w:1 %l:1 %rn:4 %rlist:16";
  // Hmm in the Amber docs the r field is called S, 
  // representing whether you should update the conditon flags or not.

  /* Coprocessor instructions */
  ac_format Type_CDP = "%cond:4 %op:3 %subop3:1 %funcc1:4 %crn:4 %crd:4 %cp_num:4 %funcc3:3 %subop1:1 %crm:4";
  ac_format Type_CRT = "%cond:4 %op:3 %subop3:1 %funcc2:3 %l:1 %crn:4 %rd:4 %cp_num:4 %funcc3:3 %subop1:1 %crm:4";
  ac_format Type_CLS = "%cond:4 %op:3 %p:1 %u:1 %n:1 %w:1 %l:1 %rn:4 %crd:4 %cp_num:4 %imm8:8";
 
  /* Special instructions */
  ac_format Type_MSWI = "%cond:4 %op:3 %subop3:1 %swinumber:24";

  /* DSP multiply instructions */
  ac_format Type_DSPSM = "%cond:4 %sm:8 %drd:4 %drn:4 %rs:4 %subop2:1 %yy:1 %xx:1 %subop1:1 %rm:4";

  /* Data processing instructions - ALU */
  ac_instr<Type_DPI1> and1, eor1, sub1, rsb1, add1, adc1, sbc1, rsc1, tst1, teq1, cmp1, cmn1, orr1, mov1, bic1, mvn1;
  ac_instr<Type_DPI2> and2, eor2, sub2, rsb2, add2, adc2, sbc2, rsc2, tst2, teq2, cmp2, cmn2, orr2, mov2, bic2, mvn2;
  ac_instr<Type_DPI3> and3, eor3, sub3, rsb3, add3, adc3, sbc3, rsc3, tst3, teq3, cmp3, cmn3, orr3, mov3, bic3, mvn3;

  /* Branch instructions */
  ac_instr<Type_BRANCH> b;

  /* Swap and multiply */
  ac_instr<Type_SWAP> swp, swpb;
  ac_instr<Type_MULT> mla, mul;

  /* Load/Store */
  ac_instr<Type_LSI> ldr1, ldrb1, str1, strb1;
  ac_instr<Type_LSR> ldr2, ldrb2, str2, strb2;
  //Removed LDRT / STRT instructions.

  //Not supported //ac_instr<Type_LSE> ldrh, ldrsb, ldrsh, strh, ldrd, strd; // ldrd e strd sao instrucoes DSP
  ac_instr<Type_MTRANS> ldm, stm;

  /* Coprocessor instructions */
  ac_instr<Type_CDP> cdp;
  ac_instr<Type_CRT> mcr, mrc;
  ac_instr<Type_CLS> ldc, stc;

  /* Special instructions */
  ac_instr<Type_MSWI> swi;
  
  /* ARM register aliases */
  ac_asm_map reg {
   "r"[0..15] = [0..15];
   "a"[1..4] = [0..3];
   "v"[1..8] = [4..11];
   "wr" = 7;
   "sb" = 9;
   "sl" = 10;
   "fp" = 11;
   "ip" = 12;
   "sp" = 13;
   "lr" = 14;
   "pc" = 15;
  }

  /* ARM instruction predicates */
  ac_asm_map cond {
    "eq" = 0;
    "ne" = 1;
    "cs", "hs" = 2;
    "cc", "lo" = 3;
    "mi" = 4; 
    "pl" = 5;
    "vs" = 6;
    "vc" = 7;
    "hi" = 8;
    "ls" = 9;
    "ge" = 10;
    "lt" = 11;
    "gt" = 12;
    "le" = 13;
    ""   = 14;
  }

  /* ARM operand shifting options */
  ac_asm_map shift {
    "LSL", "ASL", "lsl", "asl" = 0;
    "LSR", "lsr" = 1;
    "ASR", "asr" = 2;
    "ROR", "ror" = 3;
  }

  /* ARM 's flag' switch */
  ac_asm_map sf {
    "" = 0;
    "s" = 1;    
  }

  /* Multiple load/store stack specification aliases */
  ac_asm_map mlstype {
    "da" = 0;
    "ia" = 1;
    "db" = 2; 
    "ib" = 3;
  }
  ac_asm_map lstype {
    "fa" = 0;
    "fd" = 1;
    "ea" = 2; 
    "ed" = 3;
  }

  ac_asm_map sstype {
    "ed" = 0;
    "ea" = 1;
    "fd" = 2;
    "fa" = 3;
  }  


  ISA_CTOR(arm) {

    /* Defining assembler-specific constraints */
    assembler.set_comment("@");	
    assembler.set_line_comment("@#");

    /**************************************/
    /* Data processing instructions - ALU */
    /**************************************/

    and1.set_asm("and%[cond]%sf %reg, %reg, %reg", cond, s, rd, rn, rm, shiftamount=0, shift=0); 
    and1.set_asm("and%[cond]%sf %reg, %reg, %reg, %shift #%imm", cond, s, rd, rn, rm, shift, shiftamount);
    and1.set_asm("and%[cond]%sf %reg, %reg, %reg, rrx", cond, s, rd, rn, rm, shift=3, shiftamount=0);
    and1.set_decoder(op=0x00, subop1=0x00, func1=0x00);
    
    and2.set_asm("and%[cond]%sf %reg, %reg, %reg, %shift %reg", cond, s, rd, rn, rm, shift, rs); 
    and2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x00);

    and3.set_asm("and%[cond]%sf %reg, %reg, #%imm(aimm)", cond, s, rd, rn, rotate+imm8);
    and3.set_decoder(op=0x01, func1=0x00);

    
    eor1.set_asm("eor%[cond]%sf %reg, %reg, %reg", cond, s, rd, rn, rm, shiftamount=0, shift=0); 
    eor1.set_asm("eor%[cond]%sf %reg, %reg, %reg, %shift #%imm", cond, s, rd, rn, rm, shift, shiftamount);
    eor1.set_asm("eor%[cond]%sf %reg, %reg, %reg, rrx", cond, s, rd, rn, rm, shift=3, shiftamount=0);
    eor1.set_decoder(op=0x00, subop1=0x00, func1=0x01);
    
    eor2.set_asm("eor%[cond]%sf %reg, %reg, %reg, %shift %reg", cond, s, rd, rn, rm, shift, rs); 
    eor2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x01);
    
    eor3.set_asm("eor%[cond]%sf %reg, %reg, #%imm(aimm)", cond, s, rd, rn, rotate+imm8);    
    eor3.set_decoder(op=0x01, func1=0x01);
   
 
    sub1.set_asm("sub%[cond]%sf %reg, %reg, %reg", cond, s, rd, rn, rm, shiftamount=0, shift=0); 
    sub1.set_asm("sub%[cond]%sf %reg, %reg, %reg, %shift #%imm", cond, s, rd, rn, rm, shift, shiftamount);
    sub1.set_asm("sub%[cond]%sf %reg, %reg, %reg, rrx", cond, s, rd, rn, rm, shift=3, shiftamount=0);
    sub1.set_decoder(op=0x00, subop1=0x00, func1=0x02);
    
    sub2.set_asm("sub%[cond]%sf %reg, %reg, %reg, %shift %reg", cond, s, rd, rn, rm, shift, rs); 
    sub2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x02);
    
    sub3.set_asm("sub%[cond]%sf %reg, %reg, #%imm(aimm)", cond, s, rd, rn, rotate+imm8);
    sub3.set_decoder(op=0x01, func1=0x02);
   
 
    rsb1.set_asm("rsb%[cond]%sf %reg, %reg, %reg", cond, s, rd, rn, rm, shiftamount=0, shift=0); 
    rsb1.set_asm("rsb%[cond]%sf %reg, %reg, %reg, %shift #%imm", cond, s, rd, rn, rm, shift, shiftamount);
    rsb1.set_asm("rsb%[cond]%sf %reg, %reg, %reg, rrx", cond, s, rd, rn, rm, shift=3, shiftamount=0);
    rsb1.set_decoder(op=0x00, subop1=0x00, func1=0x03);
    
    rsb2.set_asm("rsb%[cond]%sf %reg, %reg, %reg, %shift %reg", cond, s, rd, rn, rm, shift, rs); 
    rsb2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x03);
    
    rsb3.set_asm("rsb%[cond]%sf %reg, %reg, #%imm(aimm)", cond, s, rd, rn, rotate+imm8);
    rsb3.set_decoder(op=0x01, func1=0x03);


    add1.set_asm("add%[cond]%sf %reg, %reg, %reg", cond, s, rd, rn, rm, shiftamount=0, shift=0); 
    add1.set_asm("add%[cond]%sf %reg, %reg, %reg, %shift #%imm", cond, s, rd, rn, rm, shift, shiftamount);
    add1.set_asm("add%[cond]%sf %reg, %reg, %reg, rrx", cond, s, rd, rn, rm, shift=3, shiftamount=0);
    add1.set_asm("add%[cond]%sf %reg, PC, %reg", cond, s, rd, rm, shiftamount=0, shift=0, rn=reg.map_to("pc")); 
    add1.set_decoder(op=0x00, subop1=0x00, func1=0x04);

    add2.set_asm("add%[cond]%sf %reg, %reg, %reg, %shift %reg", cond, s, rd, rn, rm, shift, rs); 
    add2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x04);

    add3.set_asm("add%[cond]%sf %reg, %reg, #%imm(aimm)", cond, s, rd, rn, rotate+imm8);
    // Pseudo instruction: ADR
    add3.set_asm("adr%[cond]%sf %reg, %exp(pcrelrot)", cond, s, rd, func1+rotate+imm8, rn=reg.map_to("pc"));
    add3.set_decoder(op=0x01, func1=0x04);


    adc1.set_asm("adc%[cond]%sf %reg, %reg, %reg", cond, s, rd, rn, rm, shiftamount=0, shift=0); 
    adc1.set_asm("adc%[cond]%sf %reg, %reg, %reg, %shift #%imm", cond, s, rd, rn, rm, shift, shiftamount);
    adc1.set_asm("adc%[cond]%sf %reg, %reg, %reg, rrx", cond, s, rd, rn, rm, shift=3, shiftamount=0);
    adc1.set_decoder(op=0x00, subop1=0x00, func1=0x05);

    adc2.set_asm("adc%[cond]%sf %reg, %reg, %reg, %shift %reg", cond, s, rd, rn, rm, shift, rs); 
    adc2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x05);

    adc3.set_asm("adc%[cond]%sf %reg, %reg, #%imm(aimm)", cond, s, rd, rn, rotate+imm8);
    adc3.set_decoder(op=0x01, func1=0x05);


    sbc1.set_asm("sbc%[cond]%sf %reg, %reg, %reg", cond, s, rd, rn, rm, shiftamount=0, shift=0); 
    sbc1.set_asm("sbc%[cond]%sf %reg, %reg, %reg, %shift #%imm", cond, s, rd, rn, rm, shift, shiftamount);
    sbc1.set_asm("sbc%[cond]%sf %reg, %reg, %reg, rrx", cond, s, rd, rn, rm, shift=3, shiftamount=0);
    sbc1.set_decoder(op=0x00, subop1=0x00, func1=0x06);

    sbc2.set_asm("sbc%[cond]%sf %reg, %reg, %reg, %shift %reg", cond, s, rd, rn, rm, shift, rs); 
    sbc2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x06);

    sbc3.set_asm("sbc%[cond]%sf %reg, %reg, #%imm(aimm)", cond, s, rd, rn, rotate+imm8);
    sbc3.set_decoder(op=0x01, func1=0x06);


    rsc1.set_asm("rsc%[cond]%sf %reg, %reg, %reg", cond, s, rd, rn, rm, shiftamount=0, shift=0); 
    rsc1.set_asm("rsc%[cond]%sf %reg, %reg, %reg, %shift #%imm", cond, s, rd, rn, rm, shift, shiftamount);
    rsc1.set_asm("rsc%[cond]%sf %reg, %reg, %reg, rrx", cond, s, rd, rn, rm, shift=3, shiftamount=0);
    rsc1.set_decoder(op=0x00, subop1=0x00, func1=0x07);

    rsc2.set_asm("rsc%[cond]%sf %reg, %reg, %reg, %shift %reg", cond, s, rd, rn, rm, shift, rs); 
    rsc2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x07);

    rsc3.set_asm("rsc%[cond]%sf %reg, %reg, #%imm(aimm)", cond, s, rd, rn, rotate+imm8);
    rsc3.set_decoder(op=0x01, func1=0x07);


    tst1.set_asm("tst%[cond] %reg, %reg", cond, rn, rm, rd=0, shiftamount=0, shift=0);
    tst1.set_asm("tst%[cond] %reg, %reg, %shift #%imm", cond, rn, rm, shift, shiftamount, rd=0);
    tst1.set_asm("tst%[cond] %reg, %reg, rrx", cond, rn, rm, shift=3, shiftamount=0, rd=0);
    tst1.set_decoder(op=0x00, subop1=0x00, func1=0x08, s=0x01);

    tst2.set_asm("tst%[cond] %reg, %reg, %shift %reg", cond, rn, rm, shift, rs, rd=0);
    tst2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x08, s=0x01);

    tst3.set_asm("tst%[cond] %reg, #%imm(aimm)", cond, rn, rotate+imm8, rd=0);
    tst3.set_decoder(op=0x01, func1=0x08, s=0x01);


    teq1.set_asm("teq%[cond] %reg, %reg", cond, rn, rm, rd=0, shiftamount=0, shift=0);
    teq1.set_asm("teq%[cond] %reg, %reg, %shift #%imm", cond, rn, rm, shift, shiftamount, rd=0);
    teq1.set_asm("teq%[cond] %reg, %reg, rrx", cond, rn, rm, shift=3, shiftamount=0, rd=0);
    teq1.set_decoder(op=0x00, subop1=0x00, func1=0x09, s=0x01);

    teq2.set_asm("teq%[cond] %reg, %reg, %shift %reg", cond, rn, rm, shift, rs, rd=0);
    teq2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x09, s=0x01);

    teq3.set_asm("teq%[cond] %reg, #%imm(aimm)", cond, rn, rotate+imm8, rd=0);
    teq3.set_decoder(op=0x01, func1=0x09, s=0x01);


    cmp1.set_asm("cmp%[cond] %reg, %reg", cond, rn, rm, rd=0, shiftamount=0, shift=0);
    cmp1.set_asm("cmp%[cond] %reg, %reg, %shift #%imm", cond, rn, rm, shift, shiftamount, rd=0);
    cmp1.set_asm("cmp%[cond] %reg, %reg, rrx", cond, rn, rm, shift=3, shiftamount=0, rd=0);
    cmp1.set_decoder(op=0x00, subop1=0x00, func1=0x0A, s=0x01);

    cmp2.set_asm("cmp%[cond] %reg, %reg, %shift %reg", cond, rn, rm, shift, rs, rd=0);
    cmp2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x0A, s=0x01);

    cmp3.set_asm("cmp%[cond] %reg, #%imm(aimm)", cond, rn, rotate+imm8, rd=0);
    cmp3.set_decoder(op=0x01, func1=0x0A, s=0x01);


    cmn1.set_asm("cmn%[cond] %reg, %reg", cond, rn, rm, rd=0, shiftamount=0, shift=0);
    cmn1.set_asm("cmn%[cond] %reg, %reg, %shift #%imm", cond, rn, rm, shift, shiftamount, rd=0);
    cmn1.set_asm("cmn%[cond] %reg, %reg, rrx", cond, rn, rm, shift=3, shiftamount=0, rd=0);
    cmn1.set_decoder(op=0x00, subop1=0x00, func1=0x0B, s=0x01);

    cmn2.set_asm("cmn%[cond] %reg, %reg, %shift %reg", cond, rn, rm, shift, rs, rd=0);
    cmn2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x0B, s=0x01);

    cmn3.set_asm("cmn%[cond] %reg, #%imm(aimm)", cond, rn, rotate+imm8, rd=0);
    cmn3.set_decoder(op=0x01, func1=0x0B, s=0x01);


    orr1.set_asm("orr%[cond]%sf %reg, %reg, %reg", cond, s, rd, rn, rm, shiftamount=0, shift=0); 
    orr1.set_asm("orr%[cond]%sf %reg, %reg, %reg, %shift #%imm", cond, s, rd, rn, rm, shift, shiftamount);
    orr1.set_asm("orr%[cond]%sf %reg, %reg, %reg, rrx", cond, s, rd, rn, rm, shift=3, shiftamount=0);
    orr1.set_decoder(op=0x00, subop1=0x00, func1=0x0C);

    orr2.set_asm("orr%[cond]%sf %reg, %reg, %reg, %shift %reg", cond, s, rd, rn, rm, shift, rs); 
    orr2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x0C);

    orr3.set_asm("orr%[cond]%sf %reg, %reg, #%imm(aimm)", cond, s, rd, rn, rotate+imm8);
    orr3.set_decoder(op=0x01, func1=0x0C);


    mov1.set_asm("mov%[cond]%sf %reg, %reg", cond, s, rd, rm, rn=0, shiftamount=0, shift=0);
    mov1.set_asm("mov r15, r14", cond=0xE, s=0, rd=0xF, rm=0xE, rn=0, shiftamount=0, shift=0);
    mov1.set_asm("mov r0, r0", cond=0xE, s=0, rd=0x0, rm=0x0, rn=0, shiftamount=0, shift=0);
    mov1.set_asm("mov%[cond]%sf %reg, %reg, %shift #%imm", cond, s, rd, rm, shift, shiftamount, rn=0);
    mov1.set_asm("mov%[cond]%sf %reg, %reg, rrx", cond, s, rd, rm, shift=3, shiftamount=0, rn=0);
    mov1.set_decoder(op=0x00, subop1=0x00, func1=0x0D);

    mov2.set_asm("mov%[cond]%sf %reg, %reg, %shift %reg", cond, s, rd, rm, shift, rs, rn=0);
    mov2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x0D);

    mov3.set_asm("mov%[cond]%sf %reg, #%imm(aimm)", cond, s, rd, rotate+imm8, rn=0);
    mov3.set_decoder(op=0x01, func1=0x0D);


    bic1.set_asm("bic%[cond]%sf %reg, %reg, %reg", cond, s, rd, rn, rm, shiftamount=0, shift=0); 
    bic1.set_asm("bic%[cond]%sf %reg, %reg, %reg, %shift #%imm", cond, s, rd, rn, rm, shift, shiftamount);
    bic1.set_asm("bic%[cond]%sf %reg, %reg, %reg, rrx", cond, s, rd, rn, rm, shift=3, shiftamount=0);
    bic1.set_decoder(op=0x00, subop1=0x00, func1=0x0E);

    bic2.set_asm("bic%[cond]%sf %reg, %reg, %reg, %shift %reg", cond, s, rd, rn, rm, shift, rs); 
    bic2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x0E);

    bic3.set_asm("bic%[cond]%sf %reg, %reg, #%imm(aimm)", cond, s, rd, rn, rotate+imm8);
    bic3.set_decoder(op=0x01, func1=0x0E);


    mvn1.set_asm("mvn%[cond]%sf %reg, %reg", cond, s, rd, rm, rn=0, shiftamount=0, shift=0);
    mvn1.set_asm("mvn%[cond]%sf %reg, %reg, %shift #%imm", cond, s, rd, rm, shift, shiftamount, rn=0);
    mvn1.set_asm("mvn%[cond]%sf %reg, %reg, rrx", cond, s, rd, rm, shift=3, shiftamount=0, rn=0);
    mvn1.set_decoder(op=0x00, subop1=0x00, func1=0x0F);

    mvn2.set_asm("mvn%[cond]%sf %reg, %reg, %shift %reg", cond, s, rd, rm, shift, rs, rn=0);
    mvn2.set_decoder(op=0x00, subop1=0x01, subop2=0x00, func1=0x0F);

    mvn3.set_asm("mvn%[cond]%sf %reg, #%imm(aimm)", cond, s, rd, rotate+imm8, rn=0, rd=0);
    mvn3.set_decoder(op=0x01, func1=0x0F);


    /***********************/
    /* Branch instructions */
    /***********************/

    b.set_asm("b%[cond] %exp(bimm)", cond, offset, h=0);
    b.set_asm("bl%[cond] %exp(bimm)", cond, offset, h=1);
    b.set_decoder(op=0x05);

    /**************************************/
    /* Swap/Multiplication instructions   */
    /**************************************/

    swp.set_asm("swp%[cond] %reg, %reg, [%reg]", cond, rd, rm, rn, rs=0x00);
    swp.set_decoder(op=0x00, subop1=0x01, subop2=0x01, func1=0x08, func2=0x00, s=0x00);

    swpb.set_asm("swp%[cond]b %reg, %reg, [%reg]", cond, rd, rm, rn, rs=0x00);
    swpb.set_decoder(op=0x00, subop1=0x01, subop2=0x01, func1=0x0A, func2=0x00, s=0x00);
    
    mul.set_asm("mul%[cond]%sf %reg, %reg, %reg", cond, s, rn, rm ,rs, rd=0x00);
    mul.set_decoder(op=0x00, subop1=0x01, subop2=0x01, func1=0x00, func2=0x00);

    mla.set_asm("mla%[cond]%sf %reg, %reg, %reg, %reg", cond, s, rn, rm, rs, rd);
    mla.set_decoder(op=0x00, subop1=0x01, subop2=0x01, func1=0x01, func2=0x00);

    /****************************/
    /* Load/store instructions  */
    /****************************/

    // Note: Extensive syntax overloading is used in these instructions due to the nature
    // of the addressing modes syntax for load/store instructions. Therefore, each instruction
    // is followed by comments regarding which addressing mode is implemented. For more
    // information, please refer to any ARM Assembly Language guide.

    //LDR
    // Includes all addressing syntaxes in addressing mode 2 - load/store instructions
    //  Immediate offset/pre-indexed/post-indexed (Base plus offset addressing)
    //   Normal base plus offset/Register indirect (p=1 w=0)
    ldr1.set_asm("ldr%[cond] %reg, [%reg]", cond, rd, rn, imm12=0x0, p=1, u=1, w=0);
    ldr1.set_asm("ldr%[cond] %reg, [%reg, #+%imm]", cond, rd, rn, imm12, p=1, u=1, w=0);
    ldr1.set_asm("ldr%[cond] %reg, [%reg, #-%imm]", cond, rd, rn, imm12, p=1, u=0, w=0);
    ldr1.set_asm("ldr%[cond] %reg, [%reg, #%imm]", cond, rd, rn, imm12, p=1, u=1, w=0);
    // Aditional LDR use (pseudo syntax?) - only for this instruction, not for variants - comforming to gas
    ldr1.set_asm("ldr%[cond] %reg, %exp(pcrelldr)", cond, rd, u+imm12, rn=0x0f, p=1, w=0);
    //   Pre-indexed (p=1 w=1)
    ldr1.set_asm("ldr%[cond] %reg, [%reg, #+%imm]!", cond, rd, rn, imm12, p=1, u=1, w=1);
    ldr1.set_asm("ldr%[cond] %reg, [%reg, #-%imm]!", cond, rd, rn, imm12, p=1, u=0, w=1);
    ldr1.set_asm("ldr%[cond] %reg, [%reg, #%imm]!", cond, rd, rn, imm12, p=1, u=1, w=1);
    //   Post-indexed (p=0 w=0)
    ldr1.set_asm("ldr%[cond] %reg, [%reg], #+%imm", cond, rd, rn, imm12, u=0x01, p=0x00, w=0x00); 
    ldr1.set_asm("ldr%[cond] %reg, [%reg], #-%imm", cond, rd, rn, imm12, u=0x00, p=0x00, w=0x00); 
    ldr1.set_asm("ldr%[cond] %reg, [%reg], #%imm", cond, rd, rn, imm12, u=0x01, p=0x00, w=0x00); 
    ldr1.set_decoder(op=0x02, b=0x00, l=0x01);
    //  Base plus (scaled) index addressing (normal/pre-indexed/post-indexed)
    //   Normal base plus index addressing (p=1 w=0)
    ldr2.set_asm("ldr%[cond] %reg, [%reg, +%reg]", cond, rd, rn, rm, p=1, w=0, shiftamount=0, shift=0, u=1);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, -%reg]", cond, rd, rn, rm, p=1, w=0, shiftamount=0, shift=0, u=0);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, %reg]", cond, rd, rn, rm, p=1, w=0, shiftamount=0, shift=0, u=1);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, +%reg, %shift #%imm]", cond, rd, rn, rm, shift, shiftamount, p=1, w=0, u=1);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, -%reg, %shift #%imm]", cond, rd, rn, rm, shift, shiftamount, p=1, w=0, u=0);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, %reg, %shift #%imm]", cond, rd, rn, rm, shift, shiftamount, p=1, w=0, u=1);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, +%reg, rrx]", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=0, u=1);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, -%reg, rrx]", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=0, u=0);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, %reg, rrx]", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=0, u=1);
    //   Pre-indexed (p=1 w=1)
    ldr2.set_asm("ldr%[cond] %reg, [%reg, +%reg]!", cond, rd, rn, rm, p=1, w=1, shiftamount=0, shift=0, u=1);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, -%reg]!", cond, rd, rn, rm, p=1, w=1, shiftamount=0, shift=0, u=0);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, %reg]!", cond, rd, rn, rm, p=1, w=1, shiftamount=0, shift=0, u=1);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, +%reg, %shift #%imm]!", cond, rd, rn, rm, shift, shiftamount, p=1, w=1, u=1);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, -%reg, %shift #%imm]!", cond, rd, rn, rm, shift, shiftamount, p=1, w=1, u=0);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, %reg, %shift #%imm]!", cond, rd, rn, rm, shift, shiftamount, p=1, w=1, u=1);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, +%reg, rrx]!", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=1, u=1);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, -%reg, rrx]!", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=1, u=0);
    ldr2.set_asm("ldr%[cond] %reg, [%reg, %reg, rrx]!", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=1, u=1);
    //   Post-indexed (p=0 w=0)
    ldr2.set_asm("ldr%[cond] %reg, [%reg], +%reg", cond, rd, rn, rm, shiftamount=0x00, shift=0x00, u=0x01, p=0x00, w=0x00); 
    ldr2.set_asm("ldr%[cond] %reg, [%reg], -%reg", cond, rd, rn, rm, shiftamount=0x00, shift=0x00, u=0x00, p=0x00, w=0x00); 
    ldr2.set_asm("ldr%[cond] %reg, [%reg], %reg", cond, rd, rn, rm, shiftamount=0x00, shift=0x00, u=0x01, p=0x00, w=0x00); 
    ldr2.set_asm("ldr%[cond] %reg, [%reg], +%reg, %shift #%imm", cond, rd, rn, rm, shift, shiftamount, u=0x01, p=0x00, w=0x00);
    ldr2.set_asm("ldr%[cond] %reg, [%reg], -%reg, %shift #%imm", cond, rd, rn, rm, shift, shiftamount, u=0x00, p=0x00, w=0x00);
    ldr2.set_asm("ldr%[cond] %reg, [%reg], %reg, %shift #%imm", cond, rd, rn, rm, shift, shiftamount, u=0x01, p=0x00, w=0x00);
    ldr2.set_asm("ldr%[cond] %reg, [%reg], +%reg, rrx", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, u=0x01, p=0x00, w=0x00);
    ldr2.set_asm("ldr%[cond] %reg, [%reg], -%reg, rrx", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, u=0x00, p=0x00, w=0x00);
    ldr2.set_asm("ldr%[cond] %reg, [%reg], %reg, rrx", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, u=0x01, p=0x00, w=0x00);
    ldr2.set_decoder(op=0x03, subop1=0x00, b=0x00, l=0x01);

    //LDRB
    // Includes all addressing syntaxes in addressing mode 2 - load/store instructions
    //  Immediate offset/pre-indexed/post-indexed (Base plus offset addressing)
    //   Normal base plus offset/Register indirect (p=1 w=0)
    ldrb1.set_asm("ldr%[cond]b %reg, [%reg]", cond, rd, rn, imm12=0x0, p=1, u=1, w=0);
    ldrb1.set_asm("ldr%[cond]b %reg, [%reg, #+%imm]", cond, rd, rn, imm12, p=1, u=1, w=0);
    ldrb1.set_asm("ldr%[cond]b %reg, [%reg, #-%imm]", cond, rd, rn, imm12, p=1, u=0, w=0);
    ldrb1.set_asm("ldr%[cond]b %reg, [%reg, #%imm]", cond, rd, rn, imm12, p=1, u=1, w=0);
    //   Pre-indexed (p=1 w=1)
    ldrb1.set_asm("ldr%[cond]b %reg, [%reg, #+%imm]!", cond, rd, rn, imm12, p=1, u=1, w=1);
    ldrb1.set_asm("ldr%[cond]b %reg, [%reg, #-%imm]!", cond, rd, rn, imm12, p=1, u=0, w=1);
    ldrb1.set_asm("ldr%[cond]b %reg, [%reg, #%imm]!", cond, rd, rn, imm12, p=1, u=1, w=1);
    //   Post-indexed (p=0 w=0)
    ldrb1.set_asm("ldr%[cond]b %reg, [%reg], #+%imm", cond, rd, rn, imm12, u=0x01, p=0x00, w=0x00); 
    ldrb1.set_asm("ldr%[cond]b %reg, [%reg], #-%imm", cond, rd, rn, imm12, u=0x00, p=0x00, w=0x00); 
    ldrb1.set_asm("ldr%[cond]b %reg, [%reg], #%imm", cond, rd, rn, imm12, u=0x01, p=0x00, w=0x00); 
    ldrb1.set_decoder(op=0x02, b=0x01, l=0x01);
    //  Base plus (scaled) index addressing (normal/pre-indexed/post-indexed)
    //   Normal base plus index addressing (p=1 w=0)
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, +%reg]", cond, rd, rn, rm, p=1, w=0, shiftamount=0, shift=0, u=1);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, -%reg]", cond, rd, rn, rm, p=1, w=0, shiftamount=0, shift=0, u=0);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, %reg]", cond, rd, rn, rm, p=1, w=0, shiftamount=0, shift=0, u=1);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, +%reg, %shift #%imm]", cond, rd, rn, rm, shift, shiftamount, p=1, w=0, u=1);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, -%reg, %shift #%imm]", cond, rd, rn, rm, shift, shiftamount, p=1, w=0, u=0);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, %reg, %shift #%imm]", cond, rd, rn, rm, shift, shiftamount, p=1, w=0, u=1);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, +%reg, rrx]", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=0, u=1);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, -%reg, rrx]", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=0, u=0);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, %reg, rrx]", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=0, u=1);
    //   Pre-indexed (p=1 w=1)
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, +%reg]!", cond, rd, rn, rm, p=1, w=1, shiftamount=0, shift=0, u=1);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, -%reg]!", cond, rd, rn, rm, p=1, w=1, shiftamount=0, shift=0, u=0);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, %reg]!", cond, rd, rn, rm, p=1, w=1, shiftamount=0, shift=0, u=1);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, +%reg, %shift #%imm]!", cond, rd, rn, rm, shift, shiftamount, p=1, w=1, u=1);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, -%reg, %shift #%imm]!", cond, rd, rn, rm, shift, shiftamount, p=1, w=1, u=0);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, %reg, %shift #%imm]!", cond, rd, rn, rm, shift, shiftamount, p=1, w=1, u=1);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, +%reg, rrx]!", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=1, u=1);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, -%reg, rrx]!", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=1, u=0);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg, %reg, rrx]!", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=1, u=1);
    //   Post-indexed (p=0 w=0)
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg], +%reg", cond, rd, rn, rm, shiftamount=0x00, shift=0x00, u=0x01, p=0x00, w=0x00); 
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg], -%reg", cond, rd, rn, rm, shiftamount=0x00, shift=0x00, u=0x00, p=0x00, w=0x00); 
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg], %reg", cond, rd, rn, rm, shiftamount=0x00, shift=0x00, u=0x01, p=0x00, w=0x00); 
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg], +%reg, %shift #%imm", cond, rd, rn, rm, shift, shiftamount, u=0x01, p=0x00, w=0x00);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg], -%reg, %shift #%imm", cond, rd, rn, rm, shift, shiftamount, u=0x00, p=0x00, w=0x00);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg], %reg, %shift #%imm", cond, rd, rn, rm, shift, shiftamount, u=0x01, p=0x00, w=0x00);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg], +%reg, rrx", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, u=0x01, p=0x00, w=0x00);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg], -%reg, rrx", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, u=0x00, p=0x00, w=0x00);
    ldrb2.set_asm("ldr%[cond]b %reg, [%reg], %reg, rrx", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, u=0x01, p=0x00, w=0x00);
    ldrb2.set_decoder(op=0x03, subop1=0x00, b=0x01, l=0x01);

    //LDRH
    // Supports all adressing syntaxes in addressing mode 3 - miscellaneous load/store instructions
    // (Like regular addressing modes 2, but without base plus scaled index addressing)
    //  Normal base plus offset or base plus index
    ldrh.set_asm("ldr%[cond]h %reg, [%reg]", cond, rd, rn, addr1=0, addr2=0, u=1, p=1, w=0, i=1);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg, #+%imm]", cond, rd, rn, addr1+addr2, u=1, p=1, w=0, i=1);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg, #-%imm]", cond, rd, rn, addr1+addr2, u=0, p=1, w=0, i=1);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg, #%imm]", cond, rd, rn, addr1+addr2, u=1, p=1, w=0, i=1);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg, +%reg]", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=0, i=0);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg, -%reg]", cond, rd, rn, addr2, addr1=0x0, u=0, p=1, w=0, i=0);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg, %reg]", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=0, i=0);
    //  Pre-indexed (base plus offset/base plus index)
    ldrh.set_asm("ldr%[cond]h %reg, [%reg, #+%imm]!", cond, rd, rn, addr1+addr2, u=1, p=1, w=1, i=1);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg, #-%imm]!", cond, rd, rn, addr1+addr2, u=0, p=1, w=1, i=1);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg, #%imm]!", cond, rd, rn, addr1+addr2, u=1, p=1, w=1, i=1);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg, +%reg]!", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=1, i=0);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg, -%reg]!", cond, rd, rn, addr2, addr1=0x0, u=0, p=1, w=1, i=0);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg, %reg]!", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=1, i=0);
    //  Post-indexed (base plus offset/base plus index)
    ldrh.set_asm("ldr%[cond]h %reg, [%reg], #+%imm", cond, rd, rn, addr1+addr2, u=1, p=0, w=0, i=1);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg], #-%imm", cond, rd, rn, addr1+addr2, u=0, p=0, w=0, i=1);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg], #%imm", cond, rd, rn, addr1+addr2, u=1, p=0, w=0, i=1);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg], +%reg", cond, rd, rn, addr2, addr1=0x0, u=1, p=0, w=0, i=0);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg], -%reg", cond, rd, rn, addr2, addr1=0x0, u=0, p=0, w=0, i=0);
    ldrh.set_asm("ldr%[cond]h %reg, [%reg], %reg", cond, rd, rn, addr2, addr1=0x0, u=1, p=0, w=0, i=0);
    ldrh.set_decoder(op=0x00, subop1=0x01, subop2=0x01, ss=0x00, hh=0x01, l=0x01);

    //LDRSB
    // Supports all adressing syntaxes in addressing mode 3 - miscellaneous load/store instructions
    // (Like regular addressing modes 2, but without base plus scaled index addressing)
    //  Normal base plus offset or base plus index
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg]", cond, rd, rn, addr1=0, addr2=0, u=1, p=1, w=0, i=1);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg, #+%imm]", cond, rd, rn, addr1+addr2, u=1, p=1, w=0, i=1);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg, #-%imm]", cond, rd, rn, addr1+addr2, u=0, p=1, w=0, i=1);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg, #%imm]", cond, rd, rn, addr1+addr2, u=1, p=1, w=0, i=1);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg, +%reg]", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=0, i=0);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg, -%reg]", cond, rd, rn, addr2, addr1=0x0, u=0, p=1, w=0, i=0);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg, %reg]", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=0, i=0);
    //  Pre-indexed (base plus offset/base plus index)
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg, #+%imm]!", cond, rd, rn, addr1+addr2, u=1, p=1, w=1, i=1);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg, #-%imm]!", cond, rd, rn, addr1+addr2, u=0, p=1, w=1, i=1);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg, #%imm]!", cond, rd, rn, addr1+addr2, u=1, p=1, w=1, i=1);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg, +%reg]!", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=1, i=0);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg, -%reg]!", cond, rd, rn, addr2, addr1=0x0, u=0, p=1, w=1, i=0);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg, %reg]!", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=1, i=0);
    //  Post-indexed (base plus offset/base plus index)
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg], #+%imm", cond, rd, rn, addr1+addr2, u=1, p=0, w=0, i=1);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg], #-%imm", cond, rd, rn, addr1+addr2, u=0, p=0, w=0, i=1);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg], #%imm", cond, rd, rn, addr1+addr2, u=1, p=0, w=0, i=1);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg], +%reg", cond, rd, rn, addr2, addr1=0x0, u=1, p=0, w=0, i=0);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg], -%reg", cond, rd, rn, addr2, addr1=0x0, u=0, p=0, w=0, i=0);
    ldrsb.set_asm("ldr%[cond]sb %reg, [%reg], %reg", cond, rd, rn, addr2, addr1=0x0, u=1, p=0, w=0, i=0);
    ldrsb.set_decoder(op=0x00, subop1=0x01, subop2=0x01, ss=0x01, hh=0x00, l=0x01);

    //LDRSH
    // Supports all adressing syntaxes in addressing mode 3 - miscellaneous load/store instructions
    // (Like regular addressing modes 2, but without base plus scaled index addressing)
    //  Normal base plus offset or base plus index
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg]", cond, rd, rn, addr1=0, addr2=0, u=1, p=1, w=0, i=1);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg, #+%imm]", cond, rd, rn, addr1+addr2, u=1, p=1, w=0, i=1);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg, #-%imm]", cond, rd, rn, addr1+addr2, u=0, p=1, w=0, i=1);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg, #%imm]", cond, rd, rn, addr1+addr2, u=1, p=1, w=0, i=1);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg, +%reg]", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=0, i=0);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg, -%reg]", cond, rd, rn, addr2, addr1=0x0, u=0, p=1, w=0, i=0);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg, %reg]", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=0, i=0);
    //  Pre-indexed (base plus offset/base plus index)
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg, #+%imm]!", cond, rd, rn, addr1+addr2, u=1, p=1, w=1, i=1);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg, #-%imm]!", cond, rd, rn, addr1+addr2, u=0, p=1, w=1, i=1);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg, #%imm]!", cond, rd, rn, addr1+addr2, u=1, p=1, w=1, i=1);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg, +%reg]!", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=1, i=0);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg, -%reg]!", cond, rd, rn, addr2, addr1=0x0, u=0, p=1, w=1, i=0);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg, %reg]!", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=1, i=0);
    //  Post-indexed (base plus offset/base plus index)
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg], #+%imm", cond, rd, rn, addr1+addr2, u=1, p=0, w=0, i=1);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg], #-%imm", cond, rd, rn, addr1+addr2, u=0, p=0, w=0, i=1);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg], #%imm", cond, rd, rn, addr1+addr2, u=1, p=0, w=0, i=1);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg], +%reg", cond, rd, rn, addr2, addr1=0x0, u=1, p=0, w=0, i=0);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg], -%reg", cond, rd, rn, addr2, addr1=0x0, u=0, p=0, w=0, i=0);
    ldrsh.set_asm("ldr%[cond]sh %reg, [%reg], %reg", cond, rd, rn, addr2, addr1=0x0, u=1, p=0, w=0, i=0);
    ldrsh.set_decoder(op=0x00, subop1=0x01, subop2=0x01, ss=0x01, hh=0x01, l=0x01);

    //STR
    // Includes all addressing syntaxes in addressing mode 2 - load/store instructions
    //  Immediate offset/pre-indexed/post-indexed (Base plus offset addressing)
    //   Normal base plus offset/Register indirect (p=1 w=0)
    str1.set_asm("str%[cond] %reg, [%reg]", cond, rd, rn, imm12=0x0, p=1, u=1, w=0);
    str1.set_asm("str%[cond] %reg, [%reg, #+%imm]", cond, rd, rn, imm12, p=1, u=1, w=0);
    str1.set_asm("str%[cond] %reg, [%reg, #-%imm]", cond, rd, rn, imm12, p=1, u=0, w=0);
    str1.set_asm("str%[cond] %reg, [%reg, #%imm]", cond, rd, rn, imm12, p=1, u=1, w=0);
    //   Pre-indexed (p=1 w=1)
    str1.set_asm("str%[cond] %reg, [%reg, #+%imm]!", cond, rd, rn, imm12, p=1, u=1, w=1);
    str1.set_asm("str%[cond] %reg, [%reg, #-%imm]!", cond, rd, rn, imm12, p=1, u=0, w=1);
    str1.set_asm("str%[cond] %reg, [%reg, #%imm]!", cond, rd, rn, imm12, p=1, u=1, w=1);
    //   Post-indexed (p=0 w=0)
    str1.set_asm("str%[cond] %reg, [%reg], #+%imm", cond, rd, rn, imm12, u=0x01, p=0x00, w=0x00); 
    str1.set_asm("str%[cond] %reg, [%reg], #-%imm", cond, rd, rn, imm12, u=0x00, p=0x00, w=0x00); 
    str1.set_asm("str%[cond] %reg, [%reg], #%imm", cond, rd, rn, imm12, u=0x01, p=0x00, w=0x00); 
    str1.set_decoder(op=0x02, b=0x00, l=0x00);
    //  Base plus (scaled) index addressing (normal/pre-indexed/post-indexed)
    //   Normal base plus index addressing (p=1 w=0)
    str2.set_asm("str%[cond] %reg, [%reg, +%reg]", cond, rd, rn, rm, p=1, w=0, shiftamount=0, shift=0, u=1);
    str2.set_asm("str%[cond] %reg, [%reg, -%reg]", cond, rd, rn, rm, p=1, w=0, shiftamount=0, shift=0, u=0);
    str2.set_asm("str%[cond] %reg, [%reg, %reg]", cond, rd, rn, rm, p=1, w=0, shiftamount=0, shift=0, u=1);
    str2.set_asm("str%[cond] %reg, [%reg, +%reg, %shift #%imm]", cond, rd, rn, rm, shift, shiftamount, p=1, w=0, u=1);
    str2.set_asm("str%[cond] %reg, [%reg, -%reg, %shift #%imm]", cond, rd, rn, rm, shift, shiftamount, p=1, w=0, u=0);
    str2.set_asm("str%[cond] %reg, [%reg, %reg, %shift #%imm]", cond, rd, rn, rm, shift, shiftamount, p=1, w=0, u=1);
    str2.set_asm("str%[cond] %reg, [%reg, +%reg, rrx]", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=0, u=1);
    str2.set_asm("str%[cond] %reg, [%reg, -%reg, rrx]", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=0, u=0);
    str2.set_asm("str%[cond] %reg, [%reg, %reg, rrx]", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=0, u=1);
    //   Pre-indexed (p=1 w=1)
    str2.set_asm("str%[cond] %reg, [%reg, +%reg]!", cond, rd, rn, rm, p=1, w=1, shiftamount=0, shift=0, u=1);
    str2.set_asm("str%[cond] %reg, [%reg, -%reg]!", cond, rd, rn, rm, p=1, w=1, shiftamount=0, shift=0, u=0);
    str2.set_asm("str%[cond] %reg, [%reg, %reg]!", cond, rd, rn, rm, p=1, w=1, shiftamount=0, shift=0, u=1);
    str2.set_asm("str%[cond] %reg, [%reg, +%reg, %shift #%imm]!", cond, rd, rn, rm, shift, shiftamount, p=1, w=1, u=1);
    str2.set_asm("str%[cond] %reg, [%reg, -%reg, %shift #%imm]!", cond, rd, rn, rm, shift, shiftamount, p=1, w=1, u=0);
    str2.set_asm("str%[cond] %reg, [%reg, %reg, %shift #%imm]!", cond, rd, rn, rm, shift, shiftamount, p=1, w=1, u=1);
    str2.set_asm("str%[cond] %reg, [%reg, +%reg, rrx]!", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=1, u=1);
    str2.set_asm("str%[cond] %reg, [%reg, -%reg, rrx]!", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=1, u=0);
    str2.set_asm("str%[cond] %reg, [%reg, %reg, rrx]!", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=1, u=1);
    //   Post-indexed (p=0 w=0)
    str2.set_asm("str%[cond] %reg, [%reg], +%reg", cond, rd, rn, rm, shiftamount=0x00, shift=0x00, u=0x01, p=0x00, w=0x00); 
    str2.set_asm("str%[cond] %reg, [%reg], -%reg", cond, rd, rn, rm, shiftamount=0x00, shift=0x00, u=0x00, p=0x00, w=0x00); 
    str2.set_asm("str%[cond] %reg, [%reg], %reg", cond, rd, rn, rm, shiftamount=0x00, shift=0x00, u=0x01, p=0x00, w=0x00); 
    str2.set_asm("str%[cond] %reg, [%reg], +%reg, %shift #%imm", cond, rd, rn, rm, shift, shiftamount, u=0x01, p=0x00, w=0x00);
    str2.set_asm("str%[cond] %reg, [%reg], -%reg, %shift #%imm", cond, rd, rn, rm, shift, shiftamount, u=0x00, p=0x00, w=0x00);
    str2.set_asm("str%[cond] %reg, [%reg], %reg, %shift #%imm", cond, rd, rn, rm, shift, shiftamount, u=0x01, p=0x00, w=0x00);
    str2.set_asm("str%[cond] %reg, [%reg], +%reg, rrx", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, u=0x01, p=0x00, w=0x00);
    str2.set_asm("str%[cond] %reg, [%reg], -%reg, rrx", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, u=0x00, p=0x00, w=0x00);
    str2.set_asm("str%[cond] %reg, [%reg], %reg, rrx", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, u=0x01, p=0x00, w=0x00);
    str2.set_decoder(op=0x03, subop1=0x00, b=0x00, l=0x00);


    //STRB
    // Includes all addressing syntaxes in addressing mode 2 - load/store instructions
    //  Immediate offset/pre-indexed/post-indexed (Base plus offset addressing)
    //   Normal base plus offset/Register indirect (p=1 w=0)
    strb1.set_asm("str%[cond]b %reg, [%reg]", cond, rd, rn, imm12=0x0, p=1, u=1, w=0);
    strb1.set_asm("str%[cond]b %reg, [%reg, #+%imm]", cond, rd, rn, imm12, p=1, u=1, w=0);
    strb1.set_asm("str%[cond]b %reg, [%reg, #-%imm]", cond, rd, rn, imm12, p=1, u=0, w=0);
    strb1.set_asm("str%[cond]b %reg, [%reg, #%imm]", cond, rd, rn, imm12, p=1, u=1, w=0);
    //   Pre-indexed (p=1 w=1)
    strb1.set_asm("str%[cond]b %reg, [%reg, #+%imm]!", cond, rd, rn, imm12, p=1, u=1, w=1);
    strb1.set_asm("str%[cond]b %reg, [%reg, #-%imm]!", cond, rd, rn, imm12, p=1, u=0, w=1);
    strb1.set_asm("str%[cond]b %reg, [%reg, #%imm]!", cond, rd, rn, imm12, p=1, u=1, w=1);
    //   Post-indexed (p=0 w=0)
    strb1.set_asm("str%[cond]b %reg, [%reg], #+%imm", cond, rd, rn, imm12, u=0x01, p=0x00, w=0x00); 
    strb1.set_asm("str%[cond]b %reg, [%reg], #-%imm", cond, rd, rn, imm12, u=0x00, p=0x00, w=0x00); 
    strb1.set_asm("str%[cond]b %reg, [%reg], #%imm", cond, rd, rn, imm12, u=0x01, p=0x00, w=0x00); 
    strb1.set_decoder(op=0x02, b=0x01, l=0x00);
    //  Base plus (scaled) index addressing (normal/pre-indexed/post-indexed)
    //   Normal base plus index addressing (p=1 w=0)
    strb2.set_asm("str%[cond]b %reg, [%reg, +%reg]", cond, rd, rn, rm, p=1, w=0, shiftamount=0, shift=0, u=1);
    strb2.set_asm("str%[cond]b %reg, [%reg, -%reg]", cond, rd, rn, rm, p=1, w=0, shiftamount=0, shift=0, u=0);
    strb2.set_asm("str%[cond]b %reg, [%reg, %reg]", cond, rd, rn, rm, p=1, w=0, shiftamount=0, shift=0, u=1);
    strb2.set_asm("str%[cond]b %reg, [%reg, +%reg, %shift #%imm]", cond, rd, rn, rm, shift, shiftamount, p=1, w=0, u=1);
    strb2.set_asm("str%[cond]b %reg, [%reg, -%reg, %shift #%imm]", cond, rd, rn, rm, shift, shiftamount, p=1, w=0, u=0);
    strb2.set_asm("str%[cond]b %reg, [%reg, %reg, %shift #%imm]", cond, rd, rn, rm, shift, shiftamount, p=1, w=0, u=1);
    strb2.set_asm("str%[cond]b %reg, [%reg, +%reg, rrx]", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=0, u=1);
    strb2.set_asm("str%[cond]b %reg, [%reg, -%reg, rrx]", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=0, u=0);
    strb2.set_asm("str%[cond]b %reg, [%reg, %reg, rrx]", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=0, u=1);
    //   Pre-indexed (p=1 w=1)
    strb2.set_asm("str%[cond]b %reg, [%reg, +%reg]!", cond, rd, rn, rm, p=1, w=1, shiftamount=0, shift=0, u=1);
    strb2.set_asm("str%[cond]b %reg, [%reg, -%reg]!", cond, rd, rn, rm, p=1, w=1, shiftamount=0, shift=0, u=0);
    strb2.set_asm("str%[cond]b %reg, [%reg, %reg]!", cond, rd, rn, rm, p=1, w=1, shiftamount=0, shift=0, u=1);
    strb2.set_asm("str%[cond]b %reg, [%reg, +%reg, %shift #%imm]!", cond, rd, rn, rm, shift, shiftamount, p=1, w=1, u=1);
    strb2.set_asm("str%[cond]b %reg, [%reg, -%reg, %shift #%imm]!", cond, rd, rn, rm, shift, shiftamount, p=1, w=1, u=0);
    strb2.set_asm("str%[cond]b %reg, [%reg, %reg, %shift #%imm]!", cond, rd, rn, rm, shift, shiftamount, p=1, w=1, u=1);
    strb2.set_asm("str%[cond]b %reg, [%reg, +%reg, rrx]!", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=1, u=1);
    strb2.set_asm("str%[cond]b %reg, [%reg, -%reg, rrx]!", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=1, u=0);
    strb2.set_asm("str%[cond]b %reg, [%reg, %reg, rrx]!", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, p=1, w=1, u=1);
    //   Post-indexed (p=0 w=0)
    strb2.set_asm("str%[cond]b %reg, [%reg], +%reg", cond, rd, rn, rm, shiftamount=0x00, shift=0x00, u=0x01, p=0x00, w=0x00); 
    strb2.set_asm("str%[cond]b %reg, [%reg], -%reg", cond, rd, rn, rm, shiftamount=0x00, shift=0x00, u=0x00, p=0x00, w=0x00); 
    strb2.set_asm("str%[cond]b %reg, [%reg], %reg", cond, rd, rn, rm, shiftamount=0x00, shift=0x00, u=0x01, p=0x00, w=0x00); 
    strb2.set_asm("str%[cond]b %reg, [%reg], +%reg, %shift #%imm", cond, rd, rn, rm, shift, shiftamount, u=0x01, p=0x00, w=0x00);
    strb2.set_asm("str%[cond]b %reg, [%reg], -%reg, %shift #%imm", cond, rd, rn, rm, shift, shiftamount, u=0x00, p=0x00, w=0x00);
    strb2.set_asm("str%[cond]b %reg, [%reg], %reg, %shift #%imm", cond, rd, rn, rm, shift, shiftamount, u=0x01, p=0x00, w=0x00);
    strb2.set_asm("str%[cond]b %reg, [%reg], +%reg, rrx", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, u=0x01, p=0x00, w=0x00);
    strb2.set_asm("str%[cond]b %reg, [%reg], -%reg, rrx", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, u=0x00, p=0x00, w=0x00);
    strb2.set_asm("str%[cond]b %reg, [%reg], %reg, rrx", cond, rd, rn, rm, shift=0x03, shiftamount=0x00, u=0x01, p=0x00, w=0x00);
    strb2.set_decoder(op=0x03, subop1=0x00, b=0x01, l=0x00);

    //STRH
    // Supports all adressing syntaxes in addressing mode 3 - miscellaneous load/store instructions
    // (Like regular addressing modes 2, but without base plus scaled index addressing)
    //  Normal base plus offset or base plus index
    strh.set_asm("str%[cond]h %reg, [%reg]", cond, rd, rn, addr1=0, addr2=0, u=1, p=1, w=0, i=1);
    strh.set_asm("str%[cond]h %reg, [%reg, #+%imm]", cond, rd, rn, addr1+addr2, u=1, p=1, w=0, i=1);
    strh.set_asm("str%[cond]h %reg, [%reg, #-%imm]", cond, rd, rn, addr1+addr2, u=0, p=1, w=0, i=1);
    strh.set_asm("str%[cond]h %reg, [%reg, #%imm]", cond, rd, rn, addr1+addr2, u=1, p=1, w=0, i=1);
    strh.set_asm("str%[cond]h %reg, [%reg, +%reg]", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=0, i=0);
    strh.set_asm("str%[cond]h %reg, [%reg, -%reg]", cond, rd, rn, addr2, addr1=0x0, u=0, p=1, w=0, i=0);
    strh.set_asm("str%[cond]h %reg, [%reg, %reg]", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=0, i=0);
    //  Pre-indexed (base plus offset/base plus index)
    strh.set_asm("str%[cond]h %reg, [%reg, #+%imm]!", cond, rd, rn, addr1+addr2, u=1, p=1, w=1, i=1);
    strh.set_asm("str%[cond]h %reg, [%reg, #-%imm]!", cond, rd, rn, addr1+addr2, u=0, p=1, w=1, i=1);
    strh.set_asm("str%[cond]h %reg, [%reg, #%imm]!", cond, rd, rn, addr1+addr2, u=1, p=1, w=1, i=1);
    strh.set_asm("str%[cond]h %reg, [%reg, +%reg]!", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=1, i=0);
    strh.set_asm("str%[cond]h %reg, [%reg, -%reg]!", cond, rd, rn, addr2, addr1=0x0, u=0, p=1, w=1, i=0);
    strh.set_asm("str%[cond]h %reg, [%reg, %reg]!", cond, rd, rn, addr2, addr1=0x0, u=1, p=1, w=1, i=0);
    //  Post-indexed (base plus offset/base plus index)
    strh.set_asm("str%[cond]h %reg, [%reg], #+%imm", cond, rd, rn, addr1+addr2, u=1, p=0, w=0, i=1);
    strh.set_asm("str%[cond]h %reg, [%reg], #-%imm", cond, rd, rn, addr1+addr2, u=0, p=0, w=0, i=1);
    strh.set_asm("str%[cond]h %reg, [%reg], #%imm", cond, rd, rn, addr1+addr2, u=1, p=0, w=0, i=1);
    strh.set_asm("str%[cond]h %reg, [%reg], +%reg", cond, rd, rn, addr2, addr1=0x0, u=1, p=0, w=0, i=0);
    strh.set_asm("str%[cond]h %reg, [%reg], -%reg", cond, rd, rn, addr2, addr1=0x0, u=0, p=0, w=0, i=0);
    strh.set_asm("str%[cond]h %reg, [%reg], %reg", cond, rd, rn, addr2, addr1=0x0, u=1, p=0, w=0, i=0);
    strh.set_decoder(op=0x00, subop1=0x01, subop2=0x01, ss=0x00, hh=0x01, l=0x00);

   /**  * Multiple data transfer instructions suffix: *
    ** Stack Type      |    Suffix
    ** Full ascending     *FA / STMIB LDMDA
    ** Empty ascending    *EA / STMIA LDMDB
    ** Full descending    *FD / STMDB LDMIA
    ** Empty descending   *ED / STMDA LDMIB
    ** --
    ** IB - Increment Before * IA - Increment After 
    ** DB - Decrement Before * DA - Decrement After
    */

//  ac_format Type_MTRANS = "%cond:4 %op:3 %p:1 %u:1 %r:1 %w:1 %l:1 %rn:4 %rlist:16";
    ldm.set_asm("ldm%cond%lstype %reg, {%reg...(dorlist)}", cond, p+u, rn, rlist, r=0,w=0);    
    ldm.set_asm("ldm%cond%lstype %reg!, {%reg...(dorlist)}", cond, p+u, rn, rlist, r=0, w=1);  
    ldm.set_asm("ldm%cond%lstype %reg, {%reg...(dorlist)}^", cond, p+u, rn, rlist, r=1,w=0);  
    ldm.set_asm("ldm%cond%lstype %reg!, {%reg...(dorlist)}^", cond, p+u, rn, rlist, r=1,w=1);     
    ldm.set_asm("ldm%cond%mlstype %reg, {%reg...(dorlist)}", cond, p+u, rn, rlist, r=0, w=0);    
    ldm.set_asm("ldm%cond%mlstype %reg!, {%reg...(dorlist)}", cond, p+u, rn, rlist,r=0, w=1);  
    ldm.set_asm("ldm%cond%mlstype %reg, {%reg...(dorlist)}^", cond, p+u, rn, rlist, r=1,w=0);      
    ldm.set_asm("ldm%cond%mlstype %reg!, {%reg...(dorlist)}^", cond, p+u, rn, rlist, r=1,w=1);
    ldm.set_decoder(op=0x04, l=0x01);
    
    stm.set_asm("stm%cond%sstype %reg, {%reg...(dorlist)}", cond, p+u, rn, rlist, r=0, w=0);
    stm.set_asm("stm%cond%sstype %reg!, {%reg...(dorlist)}", cond, p+u, rn, rlist, r=0, w=1);
    stm.set_asm("stm%cond%sstype %reg, {%reg...(dorlist)}^", cond, p+u, rn, rlist, r=1, w=0);
    stm.set_asm("stm%cond%sstype %reg!, {%reg...(dorlist)}^", cond, p+u, rn, rlist, r=1, w=1);
    stm.set_asm("stm%cond%mlstype %reg, {%reg...(dorlist)}", cond, p+u, rn, rlist, r=0, w=0);
    stm.set_asm("stm%cond%mlstype %reg!, {%reg...(dorlist)}", cond, p+u, rn, rlist, r=0, w=1);
    stm.set_asm("stm%cond%mlstype %reg, {%reg...(dorlist)}^", cond, p+u, rn, rlist, r=1, w=0);
    stm.set_asm("stm%cond%mlstype %reg!, {%reg...(dorlist)}^", cond, p+u, rn, rlist, r=1, w=1);
    stm.set_decoder(op=0x04, l=0x00);

    /*******************************/
    /* Coprocessor instructions    */
    /*******************************/

    /* Coprocessor instructions will NOT be implemented in this model ! */

//    cdp.set_asm("");
    cdp.set_decoder(op=0x07, subop1=0x00, subop3=0x00); 
    
//    mcr.set_asm("");
    mcr.set_decoder(op=0x07, subop1=0x01, subop3=0x00, l=0x00); 
  
//    mrc.set_asm("");
    mrc.set_decoder(op=0x07, subop1=0x01, subop3=0x00, l=0x01); 

//    ldc.set_asm("");
    ldc.set_decoder(op=0x06, l=0x01);
    
//    stc.set_asm("");
    stc.set_decoder(op=0x06, l=0x00);


    /************************/
    /* Special instructions */
    /************************/

    swi.set_asm("swi%[cond] %imm", cond, swinumber);
		swi.set_asm("swi%[cond] #%imm", cond, swinumber);
    swi.set_decoder(op=0x07, subop3=0x01);

    /************************/
    /* Pseudo instructions  */
    /************************/

    pseudo_instr ("nop"){
      "mov r0, r0";  
    }
    /*pseudo_instr ("adr %reg, %addrR8b") {
      "add %0, r15, %1";
    }
    pseudo_instr ("ldr %reg, %exprR8b") {
      "ldr %0, [r15, #%1]";
    }*/
    
  };
};
